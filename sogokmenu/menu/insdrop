#!/bin/bash
# Optimized Dropbear Installer - Maintaining Original Logic
# https://t.me/bio_hazard89

# Color definitions
RED="\033[31m"
CYAN="\033[36m"
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC="\033[0m"

clear

# Enhanced progress function
show_progress() {
    local message="$1"
    local delay="${2:-0.5}"
    echo -e "${GREEN}[Info]${NC} $message"
    sleep "$delay"
}

# Error handling function
handle_error() {
    local message="$1"
    echo -e "${RED}[Error]${NC} $message"
    echo -e "${YELLOW}Installation failed. Cleaning up...${NC}"
    cleanup_files
    exit 1
}

# Cleanup function
cleanup_files() {
    cd /root 2>/dev/null
    rm -rf dropbear-*.tar.bz2 2>/dev/null
    rm -rf dropbear-20*.* 2>/dev/null
}

# Bulletproof Dropbear status detection
get_dropbear_status() {
    local status="offline"
    
    # Method 1: Check running processes (most reliable)
    if pgrep -f "dropbear" >/dev/null 2>&1; then
        status="online"
    # Method 2: Check systemctl if available
    elif command -v systemctl >/dev/null 2>&1 && systemctl is-active dropbear >/dev/null 2>&1; then
        status="online"
    # Method 3: Check init.d service
    elif [[ -f /etc/init.d/dropbear ]] && /etc/init.d/dropbear status >/dev/null 2>&1; then
        status="online"
    # Method 4: Check listening ports (final verification)
    elif ss -tlpn 2>/dev/null | grep -q ":143.*dropbear" || netstat -tlpn 2>/dev/null | grep -q ":143.*dropbear"; then
        status="online"
    fi
    
    echo "$status"
}

# Check system requirements
check_system() {
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        handle_error "This script must be run as root"
    fi
    
    # Check internet connectivity
    if ! ping -c 1 google.com >/dev/null 2>&1; then
        handle_error "No internet connection available"
    fi
    
    # Check available disk space (minimum 50MB)
    local available_space=$(df /root | awk 'NR==2 {print $4}')
    if [[ $available_space -lt 50000 ]]; then
        handle_error "Insufficient disk space (minimum 50MB required)"
    fi
}

# Optimized Dropbear 2018 installation function
function install_dropbear_2018() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m    • INSTALL DROPBEAR 2018 •       \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    # System checks
    check_system
    
    show_progress "Removing existing Dropbear versions..."
    # Stop services first
    systemctl stop dropbear >/dev/null 2>&1
    /etc/init.d/dropbear stop >/dev/null 2>&1
    
    # Remove packages
    apt-get remove -y dropbear >/dev/null 2>&1
    apt remove --purge -y dropbear >/dev/null 2>&1
    apt autoremove -y >/dev/null 2>&1
    
    show_progress "Installing build dependencies..."
    apt update >/dev/null 2>&1
    apt install -y build-essential zlib1g-dev dropbear >/dev/null 2>&1
    
    show_progress "Downloading Dropbear 2018.76 sources..."
    if ! wget -q --timeout=30 https://matt.ucc.asn.au/dropbear/releases/dropbear-2018.76.tar.bz2; then
        handle_error "Failed to download Dropbear sources"
    fi
    
    show_progress "Extracting sources..."
    if ! tar xjf dropbear-2018.76.tar.bz2 >/dev/null 2>&1; then
        handle_error "Failed to extract sources"
    fi
    
    cd dropbear-2018.76 || handle_error "Source directory not found"
    
    show_progress "Configuring build environment..." 1
    if ! ./configure --enable-zlib >/dev/null 2>&1; then
        handle_error "Configuration failed"
    fi
    
    show_progress "Building Dropbear (this may take a few minutes)..." 2
    if ! make -j$(nproc) >/dev/null 2>&1; then
        handle_error "Compilation failed"
    fi
    
    if ! make install >/dev/null 2>&1; then
        handle_error "Installation failed"
    fi
    
    show_progress "Setting up Dropbear binary..."
    # Ensure binary is in the expected location
    if [[ -f /usr/local/sbin/dropbear ]]; then
        rm -f /usr/sbin/dropbear
        cp /usr/local/sbin/dropbear /usr/sbin/dropbear
        chmod 755 /usr/sbin/dropbear
    else
        handle_error "Dropbear binary not found after installation"
    fi
    
    show_progress "Creating Dropbear configuration..."
    # Create the exact configuration your scripts expect
cat > /etc/default/dropbear <<-'EOF'
# disabled because OpenSSH is installed
# change to NO_START=0 to enable Dropbear
NO_START=0

# Dropbear Default Port
DROPBEAR_PORT=143

# any additional arguments for Dropbear
DROPBEAR_EXTRA_ARGS="-p 109 -b /etc/kyt.txt"

# specify an optional banner file containing a message to be
# sent to clients before they connect, such as "/etc/kyt.txt"
DROPBEAR_BANNER="/etc/kyt.txt"

# RSA hostkey file (default: /etc/dropbear/dropbear_rsa_host_key)
# DROPBEAR_RSAKEY="/etc/dropbear/dropbear_rsa_host_key"

# DSS hostkey file (default: /etc/dropbear/dropbear_dss_host_key)
# DROPBEAR_DSSKEY="/etc/dropbear/dropbear_dss_host_key"

# ECDSA hostkey file (default: /etc/dropbear/dropbear_ecdsa_host_key)
# DROPBEAR_ECDSAKEY="/etc/dropbear/dropbear_ecdsa_host_key"

# Receive window size - this is a tradeoff between memory and
# network performance
DROPBEAR_RECEIVE_WINDOW=65536
EOF
    
    chmod +x /etc/default/dropbear
    
    # Create banner file if it doesn't exist
    if [[ ! -f /etc/kyt.txt ]]; then
        echo "Welcome to Dropbear SSH Server" > /etc/kyt.txt
    fi
    
    # Cleanup build files
    cd /root
    cleanup_files
    
    show_progress "Starting Dropbear services..." 1
    # Use the original restart method for compatibility
    if ! /etc/init.d/dropbear restart >/dev/null 2>&1; then
        # Fallback methods
        systemctl enable dropbear >/dev/null 2>&1
        systemctl start dropbear >/dev/null 2>&1
    fi
    
    # Verify installation
    sleep 2
    local status=$(get_dropbear_status)
    
    clear
    echo ""
    if [[ "$status" == "online" ]]; then
        echo -e "${GREEN}[Success]${NC} Dropbear 2018.76 Successfully Installed and Running!"
        echo -e "${CYAN}Service Status:${NC} ${GREEN}Running ✓${NC}"
        echo -e "${CYAN}Ports:${NC} 143, 109"
        
        # Show listening ports for verification
        local ports=$(ss -tlpn 2>/dev/null | grep dropbear | awk -F: '{print $NF}' | awk '{print $1}' | sort -n | tr '\n' ',' | sed 's/,$//' || echo "143,109")
        if [[ -n "$ports" ]]; then
            echo -e "${CYAN}Active Ports:${NC} $ports"
        fi
    else
        echo -e "${YELLOW}[Warning]${NC} Dropbear 2018.76 Installed but may need manual start"
        echo -e "${CYAN}Try running:${NC} /etc/init.d/dropbear restart"
    fi
    
    echo ""
    read -p "Press any key to exit..."
    exit 0
}

# Optimized Dropbear 2019 installation function
function install_dropbear_2019() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m    • INSTALL DROPBEAR 2019 •       \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    # System checks
    check_system
    
    show_progress "Removing existing Dropbear versions..."
    # Stop services first
    systemctl stop dropbear >/dev/null 2>&1
    /etc/init.d/dropbear stop >/dev/null 2>&1
    
    # Remove packages
    apt-get remove -y dropbear >/dev/null 2>&1
    apt remove --purge -y dropbear >/dev/null 2>&1
    apt autoremove -y >/dev/null 2>&1
    
    show_progress "Installing build dependencies..."
    apt update >/dev/null 2>&1
    apt install -y build-essential zlib1g-dev dropbear >/dev/null 2>&1
    
    show_progress "Downloading Dropbear 2019.78 sources..."
    if ! wget -q --timeout=30 https://matt.ucc.asn.au/dropbear/releases/dropbear-2019.78.tar.bz2; then
        handle_error "Failed to download Dropbear sources"
    fi
    
    show_progress "Extracting sources..."
    if ! tar xjf dropbear-2019.78.tar.bz2 >/dev/null 2>&1; then
        handle_error "Failed to extract sources"
    fi
    
    cd dropbear-2019.78 || handle_error "Source directory not found"
    
    show_progress "Configuring build environment..." 1
    if ! ./configure --enable-zlib >/dev/null 2>&1; then
        handle_error "Configuration failed"
    fi
    
    show_progress "Building Dropbear (this may take a few minutes)..." 2
    if ! make -j$(nproc) >/dev/null 2>&1; then
        handle_error "Compilation failed"
    fi
    
    if ! make install >/dev/null 2>&1; then
        handle_error "Installation failed"
    fi
    
    show_progress "Setting up Dropbear binary..."
    # Ensure binary is in the expected location
    if [[ -f /usr/local/sbin/dropbear ]]; then
        rm -f /usr/sbin/dropbear
        cp /usr/local/sbin/dropbear /usr/sbin/dropbear
        chmod 755 /usr/sbin/dropbear
    else
        handle_error "Dropbear binary not found after installation"
    fi
    
    show_progress "Creating Dropbear configuration..."
    # Create the exact configuration your scripts expect
cat > /etc/default/dropbear <<-'EOF'
# disabled because OpenSSH is installed
# change to NO_START=0 to enable Dropbear
NO_START=0

# Dropbear Default Port
DROPBEAR_PORT=143

# any additional arguments for Dropbear
DROPBEAR_EXTRA_ARGS="-p 109 -b /etc/kyt.txt"

# specify an optional banner file containing a message to be
# sent to clients before they connect, such as "/etc/kyt.txt"
DROPBEAR_BANNER="/etc/kyt.txt"

# RSA hostkey file (default: /etc/dropbear/dropbear_rsa_host_key)
# DROPBEAR_RSAKEY="/etc/dropbear/dropbear_rsa_host_key"

# DSS hostkey file (default: /etc/dropbear/dropbear_dss_host_key)
# DROPBEAR_DSSKEY="/etc/dropbear/dropbear_dss_host_key"

# ECDSA hostkey file (default: /etc/dropbear/dropbear_ecdsa_host_key)
# DROPBEAR_ECDSAKEY="/etc/dropbear/dropbear_ecdsa_host_key"

# Receive window size - this is a tradeoff between memory and
# network performance
DROPBEAR_RECEIVE_WINDOW=65536
EOF
    
    chmod +x /etc/default/dropbear
    
    # Create banner file if it doesn't exist
    if [[ ! -f /etc/kyt.txt ]]; then
        echo "Welcome to Dropbear SSH Server" > /etc/kyt.txt
    fi
    
    # Cleanup build files
    cd /root
    cleanup_files
    
    show_progress "Starting Dropbear services..." 1
    # Use the original restart method for compatibility
    if ! /etc/init.d/dropbear restart >/dev/null 2>&1; then
        # Fallback methods
        systemctl enable dropbear >/dev/null 2>&1
        systemctl start dropbear >/dev/null 2>&1
    fi
    
    # Verify installation
    sleep 2
    local status=$(get_dropbear_status)
    
    clear
    echo ""
    if [[ "$status" == "online" ]]; then
        echo -e "${GREEN}[Success]${NC} Dropbear 2019.78 Successfully Installed and Running!"
        echo -e "${CYAN}Service Status:${NC} ${GREEN}Running ✓${NC}"
        echo -e "${CYAN}Ports:${NC} 143, 109"
        
        # Show listening ports for verification
        local ports=$(ss -tlpn 2>/dev/null | grep dropbear | awk -F: '{print $NF}' | awk '{print $1}' | sort -n | tr '\n' ',' | sed 's/,$//' || echo "143,109")
        if [[ -n "$ports" ]]; then
            echo -e "${CYAN}Active Ports:${NC} $ports"
        fi
    else
        echo -e "${YELLOW}[Warning]${NC} Dropbear 2019.78 Installed but may need manual start"
        echo -e "${CYAN}Try running:${NC} /etc/init.d/dropbear restart"
    fi
    
    echo ""
    read -p "Press any key to exit..."
    exit 0
}

# Check Dropbear status function
function check_dropbear_status() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m      • Dropbear Status Check •       \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    # Check if Dropbear is installed
    if command -v dropbear >/dev/null 2>&1; then
        local version_output=$(dropbear -V 2>&1 | head -1)
        echo -e "${GREEN}[Info]${NC} Dropbear is installed"
        echo -e "${CYAN}Version:${NC} $version_output"
        
        # Use bulletproof status detection
        local status=$(get_dropbear_status)
        if [[ "$status" == "online" ]]; then
            echo -e "${CYAN}Status:${NC} ${GREEN}Running ✓${NC}"
            
            # Show detailed information
            local pids=$(pgrep -f "dropbear" | tr '\n' ' ')
            if [[ -n "$pids" ]]; then
                echo -e "${CYAN}PIDs:${NC} ${pids% }"
            fi
            
            # Show listening ports
            local ports=$(ss -tlpn 2>/dev/null | grep dropbear | awk -F: '{print $NF}' | awk '{print $1}' | sort -n | tr '\n' ',' | sed 's/,$//')
            if [[ -n "$ports" ]]; then
                echo -e "${CYAN}Ports:${NC} $ports"
            else
                echo -e "${CYAN}Ports:${NC} 143, 109 (configured)"
            fi
            
            # Connection test
            if timeout 3 nc -z localhost 143 >/dev/null 2>&1; then
                echo -e "${CYAN}Connection Test:${NC} ${GREEN}Port 143 accessible ✓${NC}"
            else
                echo -e "${CYAN}Connection Test:${NC} ${YELLOW}Port may need time to bind${NC}"
            fi
        else
            echo -e "${CYAN}Status:${NC} ${RED}Not running ✗${NC}"
            echo -e "${YELLOW}Try restarting: /etc/init.d/dropbear restart${NC}"
        fi
        
        # Check configuration
        if [[ -f /etc/default/dropbear ]]; then
            echo -e "${CYAN}Configuration:${NC} ${GREEN}Found ✓${NC}"
        else
            echo -e "${CYAN}Configuration:${NC} ${RED}Missing ✗${NC}"
        fi
        
        # Check host keys
        local key_count=$(ls -1 /etc/dropbear/dropbear_*_host_key 2>/dev/null | wc -l)
        if [[ "$key_count" -gt 0 ]]; then
            echo -e "${CYAN}Host Keys:${NC} ${GREEN}$key_count found ✓${NC}"
        else
            echo -e "${CYAN}Host Keys:${NC} ${YELLOW}Auto-generated${NC}"
        fi
        
    else
        echo -e "${RED}[Info]${NC} Dropbear is not installed"
        echo -e "${YELLOW}Use options 1 or 2 to install Dropbear${NC}"
    fi
    
    echo ""
    read -p "Press any key to return to menu..."
}

# Remove Dropbear function
function remove_dropbear() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m       • Remove Dropbear •           \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    echo -e "${RED}Warning:${NC} This will completely remove Dropbear from your system."
    echo -e "${YELLOW}Your SSH connections will be lost if you're using Dropbear.${NC}"
    echo ""
    read -rp "Are you sure you want to continue? (y/N): " confirm
    
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        show_progress "Stopping Dropbear services..."
        systemctl stop dropbear >/dev/null 2>&1
        systemctl disable dropbear >/dev/null 2>&1
        /etc/init.d/dropbear stop >/dev/null 2>&1
        pkill -f dropbear >/dev/null 2>&1
        
        show_progress "Removing Dropbear packages and files..." 1
        apt-get remove --purge -y dropbear >/dev/null 2>&1
        apt-get autoremove -y >/dev/null 2>&1
        
        # Remove binaries
        rm -f /usr/sbin/dropbear /usr/local/sbin/dropbear 2>/dev/null
        rm -f /usr/bin/dropbearkey /usr/local/bin/dropbearkey 2>/dev/null
        
        # Remove configuration (be careful not to break other scripts)
        rm -f /etc/default/dropbear 2>/dev/null
        
        # Optionally remove host keys (ask user)
        echo ""
        read -rp "Remove host keys and configuration? (y/N): " remove_keys
        if [[ "$remove_keys" =~ ^[Yy]$ ]]; then
            rm -rf /etc/dropbear 2>/dev/null
            echo -e "${YELLOW}[Info]${NC} Host keys and configuration removed"
        else
            echo -e "${YELLOW}[Info]${NC} Host keys and configuration preserved"
        fi
        
        # Clean up build files
        cleanup_files
        
        echo -e "${GREEN}[Success]${NC} Dropbear has been removed"
        
        # Verify removal
        if ! command -v dropbear >/dev/null 2>&1; then
            echo -e "${CYAN}Verification:${NC} ${GREEN}Dropbear completely removed ✓${NC}"
        else
            echo -e "${CYAN}Verification:${NC} ${YELLOW}Some files may remain${NC}"
        fi
    else
        echo -e "${YELLOW}[Info]${NC} Removal cancelled"
    fi
    
    echo ""
    read -p "Press any key to return to menu..."
}

# Main menu function
function menu() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m    • Dropbear Installer Menu •      \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}[1]${NC} Install Dropbear 2018.76 ${YELLOW}(Stable)${NC}"
    echo -e "${GREEN}[2]${NC} Install Dropbear 2019.78 ${YELLOW}(Tested)${NC}"
    echo -e "${BLUE}[3]${NC} Check Dropbear Status"
    echo -e "${PURPLE}[4]${NC} Remove Dropbear"
    echo -e "${RED}[5]${NC} Exit"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${YELLOW}Optimized installer maintaining original compatibility${NC}"
    echo ""
    
    read -rp "Select an option [1-5]: " options
    case $options in
        1)
            echo ""
            echo -e "${CYAN}Installing Dropbear 2018.76${NC}"
            echo -e "${YELLOW}This will replace any existing Dropbear installation.${NC}"
            read -rp "Continue? (y/N): " choice
            if [[ "$choice" =~ ^[Yy]$ ]]; then
                install_dropbear_2018
            else
                echo -e "${YELLOW}[Info]${NC} Installation cancelled."
                sleep 1
                menu
            fi
            ;;
        2)
            echo ""
            echo -e "${CYAN}Installing Dropbear 2019.78${NC}"
            echo -e "${YELLOW}This will replace any existing Dropbear installation.${NC}"
            read -rp "Continue? (y/N): " choice
            if [[ "$choice" =~ ^[Yy]$ ]]; then
                install_dropbear_2019
            else
                echo -e "${YELLOW}[Info]${NC} Installation cancelled."
                sleep 1
                menu
            fi
            ;;
        3)
            check_dropbear_status
            menu
            ;;
        4)
            remove_dropbear
            menu
            ;;
        5)
            echo -e "${GREEN}[Info]${NC} Exiting installer..."
            exit 0
            ;;
        *)
            echo -e "${RED}[Error]${NC} Invalid option. Please select 1-5."
            sleep 2
            menu
            ;;
    esac
}

# Start the application
menu

# Cleanup function
cleanup_installation() {
    cd /root 2>/dev/null
    rm -rf "$WORK_DIR" 2>/dev/null
    rm -rf dropbear-*.tar.bz2 2>/dev/null
}

# Check system requirements
check_requirements() {
    echo -e "${CYAN}Checking system requirements...${NC}"
    
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        handle_error "This script must be run as root"
    fi
    
    # Check internet connectivity
    if ! ping -c 1 google.com >/dev/null 2>&1; then
        handle_error "No internet connection available"
    fi
    
    # Check available disk space (minimum 100MB)
    local available_space=$(df / | awk 'NR==2 {print $4}')
    if [[ $available_space -lt 100000 ]]; then
        handle_error "Insufficient disk space (minimum 100MB required)"
    fi
    
    echo -e "${GREEN}[Info]${NC} System requirements met ✓"
}

# Install build dependencies
install_dependencies() {
    show_progress "Installing build dependencies" 2
    
    if ! apt-get update >/dev/null 2>&1; then
        handle_error "Failed to update package list"
    fi
    
    if ! apt-get install -y $BUILD_DEPS >/dev/null 2>&1; then
        handle_error "Failed to install build dependencies"
    fi
}

# Remove existing Dropbear installations
remove_existing_dropbear() {
    show_progress "Removing existing Dropbear installations" 2
    
    # Stop Dropbear service if running
    systemctl stop dropbear >/dev/null 2>&1
    /etc/init.d/dropbear stop >/dev/null 2>&1
    
    # Remove packages (but keep dependencies for reinstall)
    apt-get remove -y dropbear >/dev/null 2>&1
    
    # Clean up old binaries but preserve host keys and config for reinstall
    rm -f /usr/sbin/dropbear /usr/local/sbin/dropbear 2>/dev/null
    rm -f /usr/bin/dropbearkey /usr/local/bin/dropbearkey 2>/dev/null
}

# Generate Dropbear configuration and host keys
create_dropbear_config() {
    local version="$1"
    show_progress "Creating Dropbear configuration" 1
    
    # Create Dropbear directory if it doesn't exist
    mkdir -p /etc/dropbear
    
    # Remove old host keys to ensure clean generation
    rm -f /etc/dropbear/dropbear_*_host_key 2>/dev/null
    
    # Generate host keys - order matters for newer versions
    echo -e "${CYAN}Generating host keys for version $version...${NC}"
    
    # For 2025+ versions, generate keys in specific order and with verbose output to catch errors
    local key_generation_failed=false
    
    # Generate RSA key (always supported)
    echo -ne "${YELLOW}Generating RSA key..."
    if dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key -s 2048 >/dev/null 2>&1; then
        echo -e " ${GREEN}✓${NC}"
    else
        echo -e " ${RED}✗${NC}"
        key_generation_failed=true
    fi
    
    # Generate ECDSA key (modern standard)
    echo -ne "${YELLOW}Generating ECDSA key..."
    if dropbearkey -t ecdsa -f /etc/dropbear/dropbear_ecdsa_host_key -s 256 >/dev/null 2>&1; then
        echo -e " ${GREEN}✓${NC}"
    else
        echo -e " ${RED}✗${NC}"
    fi
    
    # Generate ED25519 key (required for 2025+ versions)
    echo -ne "${YELLOW}Generating ED25519 key..."
    if dropbearkey -t ed25519 -f /etc/dropbear/dropbear_ed25519_host_key >/dev/null 2>&1; then
        echo -e " ${GREEN}✓${NC}"
    else
        echo -e " ${RED}✗${NC}"
        # For 2025+ versions, this is critical
        if [[ "$version" =~ ^202[5-9] ]]; then
            key_generation_failed=true
        fi
    fi
    
    # Generate DSS key (legacy, only for older client compatibility)
    if [[ ! "$version" =~ ^202[5-9] ]]; then
        echo -ne "${YELLOW}Generating DSS key..."
        if dropbearkey -t dss -f /etc/dropbear/dropbear_dss_host_key >/dev/null 2>&1; then
            echo -e " ${GREEN}✓${NC}"
        else
            echo -e " ${RED}✗${NC}"
        fi
    fi
    
    if [[ "$key_generation_failed" == "true" ]]; then
        handle_error "Critical host key generation failed for version $version"
    fi
    
    # Set proper permissions
    chmod 600 /etc/dropbear/dropbear_*_host_key 2>/dev/null
    
    # Verify keys were created
    local key_count=$(ls -1 /etc/dropbear/dropbear_*_host_key 2>/dev/null | wc -l)
    if [[ "$key_count" -lt 2 ]]; then
        handle_error "Insufficient host keys generated (found: $key_count, minimum: 2)"
    fi
    
cat > /etc/default/dropbear <<-'EOF'
# Dropbear SSH Server Configuration
# Optimized for VPN/VPS usage

# Enable Dropbear
NO_START=0

# Primary port
DROPBEAR_PORT=143

# Additional ports and banner - optimized for 2025+ versions
DROPBEAR_EXTRA_ARGS="-p 109 -b /etc/kyt.txt -K 60 -I 300"

# Banner file
DROPBEAR_BANNER="/etc/kyt.txt"

# Performance optimization for newer versions
DROPBEAR_RECEIVE_WINDOW=65536

# Host key files (order matters for negotiation)
DROPBEAR_RSAKEY="/etc/dropbear/dropbear_rsa_host_key"
DROPBEAR_ECDSAKEY="/etc/dropbear/dropbear_ecdsa_host_key"
DROPBEAR_ED25519KEY="/etc/dropbear/dropbear_ed25519_host_key"
EOF

    # Create systemd service file for better 2025+ compatibility
    cat > /etc/systemd/system/dropbear.service <<-'EOF'
[Unit]
Description=Lightweight SSH server
Documentation=man:dropbear(8)
After=network.target auditd.service
ConditionPathExists=!/etc/dropbear/disabled

[Service]
Type=forking
ExecStart=/usr/sbin/dropbear -p 143 -p 109 -b /etc/kyt.txt -K 60 -I 300
ExecReload=/bin/kill -HUP $MAINPID
Restart=on-failure
RestartSec=5s
PIDFile=/var/run/dropbear.pid

# Security enhancements for newer versions
NoNewPrivileges=yes
PrivateTmp=yes
ProtectKernelTunables=yes
ProtectControlGroups=yes
RestrictRealtime=yes
SystemCallFilter=@system-service
SystemCallErrorNumber=EPERM

[Install]
WantedBy=multi-user.target
EOF

    chmod 644 /etc/default/dropbear
}

# Main installation function (optimized to handle any version)
install_dropbear() {
    local version="$1"
    local year="$2"
    
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m    • INSTALL DROPBEAR $year •       \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    # System checks
    check_requirements
    
    # Install dependencies
    install_dependencies
    
    # Remove existing installations
    remove_existing_dropbear
    
    # Create work directory
    mkdir -p "$WORK_DIR"
    cd "$WORK_DIR" || handle_error "Failed to create work directory"
    
    # Download source
    local archive_name="dropbear-${version}.tar.bz2"
    local download_url="$DROPBEAR_BASE_URL/$archive_name"
    
    show_progress "Downloading Dropbear $version sources" 3
    if ! wget -q --timeout=30 "$download_url"; then
        handle_error "Failed to download Dropbear sources"
    fi
    
    # Extract source
    show_progress "Extracting sources" 2
    if ! tar xjf "$archive_name" >/dev/null 2>&1; then
        handle_error "Failed to extract sources"
    fi
    
    # Build Dropbear
    local source_dir="dropbear-${version}"
    cd "$source_dir" || handle_error "Source directory not found"
    
    show_progress "Configuring build environment" 2
    if ! ./configure --enable-zlib >/dev/null 2>&1; then
        handle_error "Configuration failed"
    fi
    
    show_progress "Compiling Dropbear (this may take a few minutes)" 5
    if ! make -j$(nproc) >/dev/null 2>&1; then
        handle_error "Compilation failed"
    fi
    
    show_progress "Installing Dropbear" 2
    if ! make install >/dev/null 2>&1; then
        handle_error "Installation failed"
    fi
    
    # Install binary
    show_progress "Setting up Dropbear binary" 1
    if [[ -f /usr/local/sbin/dropbear ]]; then
        cp /usr/local/sbin/dropbear /usr/sbin/dropbear
        chmod 755 /usr/sbin/dropbear
        
        # Also copy dropbearkey for key generation
        if [[ -f /usr/local/bin/dropbearkey ]]; then
            cp /usr/local/bin/dropbearkey /usr/bin/dropbearkey
            chmod 755 /usr/bin/dropbearkey
        fi
    else
        handle_error "Dropbear binary not found after installation"
    fi
    
    # Create configuration and generate keys
    create_dropbear_config "$version"
    
    # Create banner file if it doesn't exist
    if [[ ! -f /etc/kyt.txt ]]; then
        echo "Welcome to Dropbear SSH Server" > /etc/kyt.txt
    fi
    
    # Reload systemd for new service file
    systemctl daemon-reload >/dev/null 2>&1
    
    # Start service with proper method for version
    show_progress "Starting Dropbear service" 2
    
    # Stop any existing instances first
    pkill -f dropbear 2>/dev/null
    sleep 1
    
    systemctl enable dropbear >/dev/null 2>&1
    if systemctl start dropbear >/dev/null 2>&1; then
        sleep 2  # Give service time to fully start
    else
        # Fallback to direct execution for troubleshooting
        echo -e "${YELLOW}[Warning]${NC} Systemd start failed, trying direct execution..."
        /usr/sbin/dropbear -p 143 -p 109 -b /etc/kyt.txt -K 60 -I 300 >/dev/null 2>&1 &
        sleep 2
    fi
    
    # Verify installation with bulletproof checking
    sleep 3  # Give more time for service to stabilize
    
    local final_status=$(get_dropbear_status)
    if [[ "$final_status" == "online" ]]; then
        echo -e "${GREEN}[Success]${NC} Dropbear $version installation completed successfully!"
        echo -e "${CYAN}Service Status:${NC} ${GREEN}Running ✓${NC}"
        echo -e "${CYAN}Ports:${NC} 143, 109"
        
        # Check host keys exist
        local key_count=$(ls -1 /etc/dropbear/dropbear_*_host_key 2>/dev/null | wc -l)
        echo -e "${CYAN}Host Keys:${NC} ${GREEN}$key_count generated ✓${NC}"
        
        # Show detailed status
        local details=$(get_dropbear_details)
        if [[ -n "$details" ]]; then
            echo -e "${CYAN}Details:${NC} $details"
        fi
        
        # Enhanced connection test for 2025+ versions
        echo -ne "${CYAN}Connection Test:${NC} "
        if timeout 5 ssh-keyscan -p 143 localhost >/dev/null 2>&1; then
            echo -e "${GREEN}SSH handshake successful ✓${NC}"
        elif timeout 3 nc -z localhost 143 >/dev/null 2>&1; then
            echo -e "${YELLOW}Port accessible, checking SSH protocol...${NC}"
            # Test SSH protocol negotiation
            if echo "SSH-2.0-Test" | timeout 3 nc localhost 143 | grep -q "SSH-2.0"; then
                echo -e "${CYAN}Protocol Test:${NC} ${GREEN}SSH-2.0 negotiation OK ✓${NC}"
            else
                echo -e "${CYAN}Protocol Test:${NC} ${YELLOW}May need client-side adjustments${NC}"
            fi
        else
            echo -e "${RED}Connection failed ✗${NC}"
            echo -e "${YELLOW}Note: For 2025+ versions, ensure SSH clients support modern algorithms${NC}"
        fi
        
    else
        handle_error "Dropbear service failed to start"
    fi
    
    # Cleanup
    cleanup_installation
    
    echo ""
    read -p "Press any key to return to menu..."
}

# Function to install custom Dropbear from external source
install_custom_dropbear() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m     • Install Custom Dropbear •      \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    echo -e "${YELLOW}This will install a custom/patched Dropbear version${NC}"
    echo -e "${CYAN}Useful for versions with specific patches or modifications${NC}"
    echo ""
    
    echo -e "${GREEN}[1]${NC} Install from URL (direct download)"
    echo -e "${GREEN}[2]${NC} Install from local file"
    echo -e "${GREEN}[3]${NC} Install from GitHub repository"
    echo -e "${GREEN}[4]${NC} Install with custom compile flags"
    echo -e "${RED}[5]${NC} Return to main menu"
    echo ""
    
    read -rp "Select installation method [1-5]: " method
    
    case $method in
        1)
            install_from_url
            ;;
        2)
            install_from_local
            ;;
        3)
            install_from_github
            ;;
        4)
            install_with_custom_flags
            ;;
        5)
            return
            ;;
        *)
            echo -e "${RED}[Error]${NC} Invalid option"
            sleep 2
            install_custom_dropbear
            ;;
    esac
}

# Install from direct URL
install_from_url() {
    echo ""
    echo -e "${CYAN}Enter the direct URL to the Dropbear archive:${NC}"
    echo -e "${YELLOW}Example: https://example.com/dropbear-custom-2025.88.tar.bz2${NC}"
    read -rp "URL: " custom_url
    
    if [[ -z "$custom_url" ]]; then
        echo -e "${RED}[Error]${NC} No URL provided"
        sleep 2
        return
    fi
    
    echo -e "${CYAN}Version name for this custom build:${NC}"
    read -rp "Version (e.g., 2025.88-custom): " custom_version
    
    install_custom_binary "$custom_url" "$custom_version" "url"
}

# Install from local file
install_from_local() {
    echo ""
    echo -e "${CYAN}Enter the path to local Dropbear archive:${NC}"
    read -rp "Path: " local_path
    
    if [[ ! -f "$local_path" ]]; then
        echo -e "${RED}[Error]${NC} File not found: $local_path"
        sleep 2
        return
    fi
    
    echo -e "${CYAN}Version name for this custom build:${NC}"
    read -rp "Version (e.g., 2025.88-custom): " custom_version
    
    install_custom_binary "$local_path" "$custom_version" "local"
}

# Install from GitHub
install_from_github() {
    echo ""
    echo -e "${CYAN}Enter GitHub repository (owner/repo):${NC}"
    echo -e "${YELLOW}Example: mkj/dropbear${NC}"
    read -rp "Repository: " github_repo
    
    echo -e "${CYAN}Branch or tag (default: master):${NC}"
    read -rp "Branch: " github_branch
    github_branch=${github_branch:-master}
    
    local github_url="https://github.com/${github_repo}/archive/refs/heads/${github_branch}.tar.gz"
    install_custom_binary "$github_url" "${github_branch}-$(date +%Y%m%d)" "github"
}

# Install with custom compile flags
install_with_custom_flags() {
    echo ""
    echo -e "${CYAN}Enter Dropbear version to customize:${NC}"
    read -rp "Version (e.g., 2025.88): " base_version
    
    echo -e "${CYAN}Enter custom configure flags:${NC}"
    echo -e "${YELLOW}Example: --enable-zlib --disable-wtmp --enable-bundled-libtom${NC}"
    read -rp "Flags: " custom_flags
    
    local base_url="$DROPBEAR_BASE_URL/dropbear-${base_version}.tar.bz2"
    install_custom_binary_with_flags "$base_url" "$base_version-custom" "$custom_flags"
}

# Main custom installation function
install_custom_binary() {
    local source="$1"
    local version="$2"
    local type="$3"
    
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m    • INSTALL CUSTOM DROPBEAR •      \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    echo -e "${YELLOW}Installing: $version${NC}"
    echo -e "${CYAN}Source: $source${NC}"
    echo ""
    
    # System checks
    check_requirements
    install_dependencies
    remove_existing_dropbear
    
    # Create work directory
    mkdir -p "$WORK_DIR"
    cd "$WORK_DIR" || handle_error "Failed to create work directory"
    
    # Download/copy source based on type
    case "$type" in
        "url"|"github")
            show_progress "Downloading custom Dropbear sources" 3
            if ! wget -q --timeout=60 "$source" -O custom_dropbear.tar; then
                handle_error "Failed to download from: $source"
            fi
            ;;
        "local")
            show_progress "Copying local Dropbear sources" 1
            if ! cp "$source" custom_dropbear.tar; then
                handle_error "Failed to copy local file: $source"
            fi
            ;;
    esac
    
    # Extract (handle different archive types)
    show_progress "Extracting custom sources" 2
    local extract_cmd=""
    case "$source" in
        *.tar.bz2) extract_cmd="tar xjf" ;;
        *.tar.gz|*.tgz) extract_cmd="tar xzf" ;;
        *.tar) extract_cmd="tar xf" ;;
        *.zip) extract_cmd="unzip -q" ;;
        *) extract_cmd="tar xf" ;;  # Try generic tar
    esac
    
    if ! $extract_cmd custom_dropbear.tar >/dev/null 2>&1; then
        handle_error "Failed to extract custom sources"
    fi
    
    # Find source directory (could have different names for custom builds)
    local source_dir=$(find . -maxdepth 1 -type d -name "*dropbear*" | head -1)
    if [[ -z "$source_dir" ]]; then
        source_dir=$(find . -maxdepth 1 -type d ! -name "." | head -1)
    fi
    
    if [[ -z "$source_dir" ]]; then
        handle_error "Source directory not found after extraction"
    fi
    
    cd "$source_dir" || handle_error "Failed to enter source directory"
    
    # Check if this is a proper Dropbear source
    if [[ ! -f "configure" && ! -f "Makefile" ]]; then
        handle_error "This doesn't appear to be a valid Dropbear source"
    fi
    
    # Build with standard flags (can be overridden)
    show_progress "Configuring custom build environment" 2
    local configure_flags="--enable-zlib"
    
    # Try to detect if this needs special configuration
    if grep -q "bundled-libtom" configure 2>/dev/null; then
        configure_flags="$configure_flags --enable-bundled-libtom"
    fi
    
    if ! ./configure $configure_flags >/dev/null 2>&1; then
        echo -e "${YELLOW}[Warning]${NC} Standard configure failed, trying without flags..."
        if ! ./configure >/dev/null 2>&1; then
            handle_error "Configuration failed"
        fi
    fi
    
    show_progress "Compiling custom Dropbear (this may take a few minutes)" 5
    if ! make -j$(nproc) >/dev/null 2>&1; then
        handle_error "Compilation failed"
    fi
    
    show_progress "Installing custom Dropbear" 2
    if ! make install >/dev/null 2>&1; then
        handle_error "Installation failed"
    fi
    
    # Install binaries
    show_progress "Setting up custom Dropbear binary" 1
    if [[ -f /usr/local/sbin/dropbear ]]; then
        cp /usr/local/sbin/dropbear /usr/sbin/dropbear
        chmod 755 /usr/sbin/dropbear
        
        if [[ -f /usr/local/bin/dropbearkey ]]; then
            cp /usr/local/bin/dropbearkey /usr/bin/dropbearkey
            chmod 755 /usr/bin/dropbearkey
        fi
    elif [[ -f ./dropbear ]]; then
        # Direct copy if make install didn't work
        cp ./dropbear /usr/sbin/dropbear
        chmod 755 /usr/sbin/dropbear
        
        if [[ -f ./dropbearkey ]]; then
            cp ./dropbearkey /usr/bin/dropbearkey
            chmod 755 /usr/bin/dropbearkey
        fi
    else
        handle_error "Custom Dropbear binary not found after installation"
    fi
    
    # Create configuration for custom build
    create_dropbear_config "$version"
    
    # Create banner file if it doesn't exist
    if [[ ! -f /etc/kyt.txt ]]; then
        echo "Welcome to Custom Dropbear SSH Server" > /etc/kyt.txt
    fi
    
    # Start service
    systemctl daemon-reload >/dev/null 2>&1
    show_progress "Starting custom Dropbear service" 2
    
    pkill -f dropbear 2>/dev/null
    sleep 1
    
    systemctl enable dropbear >/dev/null 2>&1
    if systemctl start dropbear >/dev/null 2>&1; then
        sleep 3
    else
        echo -e "${YELLOW}[Warning]${NC} Systemd start failed, trying direct execution..."
        /usr/sbin/dropbear -p 143 -p 109 -b /etc/kyt.txt >/dev/null 2>&1 &
        sleep 3
    fi
    
    # Verify installation
    if [[ "$(get_dropbear_status)" == "online" ]]; then
        echo -e "${GREEN}[Success]${NC} Custom Dropbear $version installation completed!"
        echo -e "${CYAN}Service Status:${NC} ${GREEN}Running ✓${NC}"
        echo -e "${CYAN}Version Check:${NC} $(dropbear -V 2>&1 | head -1)"
        
        # Show detailed status
        local details=$(get_dropbear_details)
        if [[ -n "$details" ]]; then
            echo -e "${CYAN}Details:${NC} $details"
        fi
        
        # Enhanced connection test
        if timeout 5 ssh-keyscan -p 143 localhost >/dev/null 2>&1; then
            echo -e "${CYAN}Connection Test:${NC} ${GREEN}SSH handshake successful ✓${NC}"
        elif timeout 3 nc -z localhost 143 >/dev/null 2>&1; then
            echo -e "${CYAN}Connection Test:${NC} ${YELLOW}Port accessible (may need time)${NC}"
        else
            echo -e "${CYAN}Connection Test:${NC} ${RED}Connection failed${NC}"
        fi
    else
        handle_error "Custom Dropbear service failed to start"
    fi
    
    # Cleanup
    cleanup_installation
    
    echo ""
    read -p "Press any key to return to menu..."
}

# Install with custom flags
install_custom_binary_with_flags() {
    local source="$1"
    local version="$2"
    local flags="$3"
    
    # Similar to install_custom_binary but with custom configure flags
    # [Implementation would be similar but with $flags passed to configure]
    echo -e "${CYAN}Installing with custom flags: $flags${NC}"
    # This would follow the same pattern as install_custom_binary
    # but use the custom flags in the configure step
}

# Function to copy working configuration
copy_working_config() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m     • Copy Working Configuration •   \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    echo -e "${YELLOW}This will help copy configuration from your working Dropbear 2025 setup${NC}"
    echo ""
    
    read -rp "Enter the path to your working Dropbear script: " working_script
    
    if [[ ! -f "$working_script" ]]; then
        echo -e "${RED}[Error]${NC} Script not found: $working_script"
        sleep 2
        return
    fi
    
    echo -e "${CYAN}Analyzing working script...${NC}"
    
    # Extract key configurations from working script
    echo -e "${YELLOW}Found configurations:${NC}"
    
    # Check for configure options
    local configure_opts=$(grep -o '\./configure[^;]*' "$working_script" | head -1)
    if [[ -n "$configure_opts" ]]; then
        echo "   Configure: $configure_opts"
    fi
    
    # Check for ExecStart command
    local exec_start=$(grep -A5 "ExecStart=" "$working_script" | grep "ExecStart=" | head -1)
    if [[ -n "$exec_start" ]]; then
        echo "   Service: $exec_start"
    fi
    
    # Check for host key generation
    local key_gen=$(grep -A10 -B5 "dropbearkey" "$working_script" | grep -v "^#")
    if [[ -n "$key_gen" ]]; then
        echo "   Key generation found in script"
    fi
    
    echo ""
    read -rp "Would you like me to create a compatible configuration? (y/N): " apply_config
    
    if [[ "$apply_config" =~ ^[Yy]$ ]]; then
        echo -e "${CYAN}Creating compatible configuration...${NC}"
        
        # Create a simplified, working configuration
        cat > /etc/systemd/system/dropbear.service <<-'EOF'
[Unit]
Description=Lightweight SSH server
After=network.target

[Service]
Type=simple
ExecStart=/usr/sbin/dropbear -F -p 143 -p 109 -b /etc/kyt.txt
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
EOF
        
        # Simplified default config
        cat > /etc/default/dropbear <<-'EOF'
NO_START=0
DROPBEAR_PORT=143
DROPBEAR_EXTRA_ARGS="-p 109 -b /etc/kyt.txt"
EOF
        
        echo -e "${GREEN}[Success]${NC} Compatible configuration created"
        echo -e "${YELLOW}Try reinstalling Dropbear 2025.88 now${NC}"
    fi
    
    echo ""
    read -p "Press any key to return to menu..."
}

# Diagnostic function to compare with working installation
diagnose_dropbear_issue() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m      • Dropbear Diagnostics •        \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    echo -e "${YELLOW}Collecting diagnostic information...${NC}"
    echo ""
    
    # Check current dropbear version and status
    echo -e "${CYAN}1. Current Installation:${NC}"
    if command -v dropbear >/dev/null 2>&1; then
        echo "   Version: $(dropbear -V 2>&1 | head -1)"
        echo "   Binary: $(which dropbear)"
        echo "   Size: $(ls -lh $(which dropbear) | awk '{print $5}')"
    else
        echo "   ${RED}Not installed${NC}"
    fi
    echo ""
    
    # Check configuration files
    echo -e "${CYAN}2. Configuration Files:${NC}"
    for file in /etc/default/dropbear /etc/systemd/system/dropbear.service; do
        if [[ -f "$file" ]]; then
            echo "   ✓ $file ($(stat -c%s "$file") bytes)"
        else
            echo "   ✗ $file ${RED}missing${NC}"
        fi
    done
    echo ""
    
    # Check host keys
    echo -e "${CYAN}3. Host Keys:${NC}"
    for key in /etc/dropbear/dropbear_*_host_key; do
        if [[ -f "$key" ]]; then
            local keytype=$(basename "$key" | sed 's/dropbear_\(.*\)_host_key/\1/')
            local keysize=$(stat -c%s "$key")
            echo "   ✓ $keytype ($keysize bytes)"
        fi
    done
    if ! ls /etc/dropbear/dropbear_*_host_key >/dev/null 2>&1; then
        echo "   ${RED}No host keys found${NC}"
    fi
    echo ""
    
    # Check service status
    echo -e "${CYAN}4. Service Status:${NC}"
    if systemctl is-active dropbear >/dev/null 2>&1; then
        echo "   Status: ${GREEN}Active${NC}"
        echo "   PID: $(pgrep dropbear | head -1)"
        echo "   Command: $(ps -p $(pgrep dropbear | head -1) -o cmd --no-headers 2>/dev/null)"
    else
        echo "   Status: ${RED}Inactive${NC}"
        echo "   Last error: $(systemctl status dropbear --no-pager -l | grep -i error | tail -1)"
    fi
    echo ""
    
    # Check listening ports
    echo -e "${CYAN}5. Network Status:${NC}"
    local ports=$(ss -tlpn | grep dropbear | awk -F: '{print $NF}' | awk '{print $1}' | sort -n)
    if [[ -n "$ports" ]]; then
        echo "   Listening on: $ports"
    else
        echo "   ${RED}No ports listening${NC}"
    fi
    echo ""
    
    # Test SSH handshake
    echo -e "${CYAN}6. SSH Protocol Test:${NC}"
    if timeout 3 nc -z localhost 143 >/dev/null 2>&1; then
        echo "   Port 143: ${GREEN}Accessible${NC}"
        # Try to get SSH version banner
        local banner=$(echo "" | timeout 2 nc localhost 143 2>/dev/null | head -1)
        if [[ -n "$banner" ]]; then
            echo "   Banner: $banner"
        else
            echo "   Banner: ${RED}No response${NC}"
        fi
    else
        echo "   Port 143: ${RED}Not accessible${NC}"
    fi
    
    # Check for common issues
    echo ""
    echo -e "${CYAN}7. Common Issues Check:${NC}"
    
    # Check if ED25519 key exists for 2025+ versions
    if [[ ! -f /etc/dropbear/dropbear_ed25519_host_key ]]; then
        echo "   ${RED}✗ Missing ED25519 key (required for 2025+ versions)${NC}"
    else
        echo "   ✓ ED25519 key present"
    fi
    
    # Check dropbearkey binary
    if command -v dropbearkey >/dev/null 2>&1; then
        echo "   ✓ dropbearkey available"
    else
        echo "   ${RED}✗ dropbearkey missing${NC}"
    fi
    
    # Check systemd service file syntax
    if systemd-analyze verify /etc/systemd/system/dropbear.service >/dev/null 2>&1; then
        echo "   ✓ Service file valid"
    else
        echo "   ${RED}✗ Service file has issues${NC}"
    fi
    
    echo ""
    echo -e "${YELLOW}Press any key to return to menu...${NC}"
    read -n 1
}

# Enhanced menu function - simplified for stable versions only
show_menu() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m    • Dropbear Installer Menu •      \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    echo -e "${GREEN}[1]${NC} Install Dropbear 2018.76 ${YELLOW}(Stable)${NC}"
    echo -e "${GREEN}[2]${NC} Install Dropbear 2019.78 ${YELLOW}(Tested)${NC}"
    echo -e "${BLUE}[3]${NC} Check Current Status ${YELLOW}(+ Reinstall Option)${NC}"
    echo -e "${PURPLE}[4]${NC} Remove Dropbear"
    echo -e "${RED}[5]${NC} Exit"
    
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${YELLOW}Focused on proven stable versions only${NC}"
}

# Bulletproof Dropbear status detection
get_dropbear_status() {
    local status="offline"
    local method_used=""
    
    # Method 1: Check running processes (most reliable)
    if pgrep -f "dropbear" >/dev/null 2>&1; then
        status="online"
        method_used="process"
    # Method 2: Check systemctl if available
    elif command -v systemctl >/dev/null 2>&1 && systemctl is-active dropbear >/dev/null 2>&1; then
        status="online"
        method_used="systemctl"
    # Method 3: Check init.d service
    elif [[ -f /etc/init.d/dropbear ]] && /etc/init.d/dropbear status >/dev/null 2>&1; then
        status="online"
        method_used="initd"
    # Method 4: Check listening ports (final verification)
    elif ss -tlpn 2>/dev/null | grep -q ":143.*dropbear" || netstat -tlpn 2>/dev/null | grep -q ":143.*dropbear"; then
        status="online"
        method_used="port"
    fi
    
    echo "$status"
}

# Get detailed Dropbear status information
get_dropbear_details() {
    local details=""
    
    # Get PID(s)
    local pids=$(pgrep -f "dropbear" | tr '\n' ' ')
    if [[ -n "$pids" ]]; then
        details+="PIDs: ${pids% } | "
    fi
    
    # Get listening ports
    local ports=""
    if command -v ss >/dev/null 2>&1; then
        ports=$(ss -tlpn 2>/dev/null | grep dropbear | awk -F: '{print $NF}' | awk '{print $1}' | sort -n | tr '\n' ',' | sed 's/,$//')
    elif command -v netstat >/dev/null 2>&1; then
        ports=$(netstat -tlpn 2>/dev/null | grep dropbear | awk '{print $4}' | cut -d: -f2 | sort -n | tr '\n' ',' | sed 's/,$//')
    fi
    if [[ -n "$ports" ]]; then
        details+="Ports: $ports | "
    fi
    
    # Get service status
    if command -v systemctl >/dev/null 2>&1; then
        local service_status=$(systemctl is-active dropbear 2>/dev/null || echo "unknown")
        details+="Service: $service_status"
    fi
    
    echo "${details% | }"
}

# Check Dropbear status with reinstall option - simplified
check_dropbear_status() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m      • Dropbear Status Check •       \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    local current_version=""
    local current_year=""
    
    # Use bulletproof status detection
    local dropbear_status=$(get_dropbear_status)
    
    if command -v dropbear >/dev/null 2>&1; then
        local version_output=$(dropbear -V 2>&1 | head -1)
        echo -e "${GREEN}[Info]${NC} Dropbear is installed"
        echo -e "${CYAN}Version:${NC} $version_output"
        
        # Extract version for reinstall option
        if [[ "$version_output" =~ dropbear_([0-9]+\.[0-9]+) ]]; then
            current_version="${BASH_REMATCH[1]}"
            # Determine year from version
            case "$current_version" in
                "2018.76") current_year="2018" ;;
                "2019.78") current_year="2019" ;;
                *) current_year=$(echo "$current_version" | cut -d. -f1) ;;
            esac
        fi
        
        # Display status with bulletproof detection
        if [[ "$dropbear_status" == "online" ]]; then
            echo -e "${CYAN}Status:${NC} ${GREEN}Running ✓${NC}"
            local details=$(get_dropbear_details)
            if [[ -n "$details" ]]; then
                echo -e "${CYAN}Details:${NC} $details"
            fi
        else
            echo -e "${CYAN}Status:${NC} ${RED}Not running ✗${NC}"
        fi
        
        if [[ -f /etc/default/dropbear ]]; then
            echo -e "${CYAN}Configuration:${NC} ${GREEN}Found ✓${NC}"
        else
            echo -e "${CYAN}Configuration:${NC} ${YELLOW}Missing${NC}"
        fi
        
        # Offer reinstall option for supported versions only
        if [[ "$current_version" == "2018.76" || "$current_version" == "2019.78" ]]; then
            echo ""
            echo -e "${YELLOW}[R]${NC} Reinstall current version ($current_version)"
            echo ""
            read -rp "Press 'R' to reinstall, or any other key to return: " choice
            case "$choice" in
                [Rr])
                    confirm_installation "$current_version" "$current_year"
                    return
                    ;;
            esac
        elif [[ -n "$current_version" ]]; then
            echo -e "${YELLOW}Note: Version $current_version detected (not officially supported by this installer)${NC}"
        fi
    else
        echo -e "${RED}[Info]${NC} Dropbear is not installed"
    fi
    
    echo ""
    read -p "Press any key to return to menu..."
}

# Remove Dropbear function
remove_dropbear() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m       • Remove Dropbear •           \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    echo -e "${RED}Warning:${NC} This will completely remove Dropbear from your system."
    read -rp "Are you sure you want to continue? (y/N): " confirm
    
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        show_progress "Stopping Dropbear services" 1
        systemctl stop dropbear >/dev/null 2>&1
        systemctl disable dropbear >/dev/null 2>&1
        /etc/init.d/dropbear stop >/dev/null 2>&1
        
        show_progress "Removing Dropbear packages and files" 2
        apt-get remove --purge -y dropbear >/dev/null 2>&1
        apt-get autoremove -y >/dev/null 2>&1
        
        rm -f /usr/sbin/dropbear /usr/local/sbin/dropbear 2>/dev/null
        rm -f /usr/bin/dropbearkey /usr/local/bin/dropbearkey 2>/dev/null
        rm -f /etc/default/dropbear 2>/dev/null
        rm -rf /etc/dropbear 2>/dev/null
        
        echo -e "${GREEN}[Success]${NC} Dropbear has been completely removed"
    else
        echo -e "${YELLOW}[Info]${NC} Removal cancelled"
    fi
    
    echo ""
    read -p "Press any key to return to menu..."
}

# Custom version installation function
install_custom_version() {
    clear
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "\033[1;37m      • Install Custom Version •      \033[0m"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    local latest_version=$(get_latest_version)
    echo -e "${CYAN}Latest available version: ${GREEN}$latest_version${NC}"
    echo -e "${YELLOW}Common versions: 2018.76, 2019.78, 2020.81, 2022.83${NC}"
    echo ""
    
    read -rp "Enter version number (e.g., 2020.81): " custom_version
    
    if [[ -z "$custom_version" ]]; then
        echo -e "${RED}[Error]${NC} No version specified"
        sleep 2
        return
    fi
    
    # Validate version format
    if [[ ! "$custom_version" =~ ^[0-9]{4}\.[0-9]{2}$ ]]; then
        echo -e "${RED}[Error]${NC} Invalid version format. Use YYYY.XX format (e.g., 2020.81)"
        sleep 2
        return
    fi
    
    # Check if version exists
    echo -e "${YELLOW}Checking if version $custom_version exists...${NC}"
    if version_exists "$custom_version"; then
        echo -e "${GREEN}[Info]${NC} Version $custom_version found ✓"
        local custom_year=$(echo "$custom_version" | cut -d. -f1)
        confirm_installation "$custom_version" "$custom_year"
    else
        echo -e "${RED}[Error]${NC} Version $custom_version not found on official repository"
        echo -e "${YELLOW}Please check the version number and try again${NC}"
        sleep 3
    fi
}
confirm_installation() {
    local version="$1"
    local year="$2"
    
    # Check if this is a reinstall
    local is_reinstall=false
    if command -v dropbear >/dev/null 2>&1; then
        local current_version=$(dropbear -V 2>&1 | head -1)
        if [[ "$current_version" =~ $version ]]; then
            is_reinstall=true
        fi
    fi
    
    echo ""
    if [[ "$is_reinstall" == "true" ]]; then
        echo -e "${YELLOW}Reinstalling Dropbear $year ($version)${NC}"
        echo -e "${CYAN}This will reinstall the current version with fresh configuration.${NC}"
    else
        echo -e "${CYAN}Installing Dropbear $year ($version)${NC}"
        echo -e "${YELLOW}This will replace any existing Dropbear installation.${NC}"
    fi
    
    read -rp "Enter your choice (y/N): " choice
    
    if [[ "$choice" =~ ^[Yy]$ ]]; then
        install_dropbear "$version" "$year"
    else
        echo -e "${YELLOW}[Info]${NC} Installation cancelled"
        sleep 1
    fi
}

# Main menu loop - simplified
main_menu() {
    while true; do
        show_menu
        read -rp "Select an option [1-5]: " option
        
        case $option in
            1)
                confirm_installation "2018.76" "2018"
                ;;
            2)
                confirm_installation "2019.78" "2019"
                ;;
            3)
                check_dropbear_status
                ;;
            4)
                remove_dropbear
                ;;
            5)
                echo -e "${GREEN}[Info]${NC} Exiting installer..."
                exit 0
                ;;
            *)
                echo -e "${RED}[Error]${NC} Invalid option. Please select 1-5."
                sleep 2
                ;;
        esac
    done
}

# Start the application
main_menu